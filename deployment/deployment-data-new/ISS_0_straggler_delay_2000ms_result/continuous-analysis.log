result_processor 0 8
result_processor 1 8
result_processor 2 8
result_processor 3 8
result_processor 4 8
result_processor 5 8
result_processor 6 8
result_processor 7 8
Processing experiment results. Start: 1 Step: 8
Processing experiment results. Start: 0 Step: 8
Processing experiment results. Start: 2 Step: 8
Processing experiment results. Start: 3 Step: 8
Processing experiment results. Start: 4 Step: 8
Processing experiment results. Start: 5 Step: 8
Processing experiment results. Start: 6 Step: 8
Processing experiment results. Start: 7 Step: 8
0000: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0000
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0000/eventDB.sqlite /root/current-deployment-data/experiment-output/0000/slave-*/*.trc
    Events loaded: 41077
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0001: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0001
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0001/eventDB.sqlite /root/current-deployment-data/experiment-output/0001/slave-*/*.trc
    Events loaded: 41031
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0002: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0002
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0002/eventDB.sqlite /root/current-deployment-data/experiment-output/0002/slave-*/*.trc
    Events loaded: 41057
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0003: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0003
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0003/eventDB.sqlite /root/current-deployment-data/experiment-output/0003/slave-*/*.trc
    Events loaded: 40926
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0004: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0004
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0004/eventDB.sqlite /root/current-deployment-data/experiment-output/0004/slave-*/*.trc
    Events loaded: 41022
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0005: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0005
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0005/eventDB.sqlite /root/current-deployment-data/experiment-output/0005/slave-*/*.trc
    Events loaded: 79704
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0006: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0006
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0006/eventDB.sqlite /root/current-deployment-data/experiment-output/0006/slave-*/*.trc
    Events loaded: 79702
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0007: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0007
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0007/eventDB.sqlite /root/current-deployment-data/experiment-output/0007/slave-*/*.trc
    Events loaded: 79762
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0008: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0008
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0008/eventDB.sqlite /root/current-deployment-data/experiment-output/0008/slave-*/*.trc
    Events loaded: 79691
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0009: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0009
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0009/eventDB.sqlite /root/current-deployment-data/experiment-output/0009/slave-*/*.trc
    Events loaded: 79616
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0010: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0010
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0010/eventDB.sqlite /root/current-deployment-data/experiment-output/0010/slave-*/*.trc
    Events loaded: 116817
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0011: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0011
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0011/eventDB.sqlite /root/current-deployment-data/experiment-output/0011/slave-*/*.trc
    Events loaded: 116564
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0012: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0012
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0012/eventDB.sqlite /root/current-deployment-data/experiment-output/0012/slave-*/*.trc
    Events loaded: 116762
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0013: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0013
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0013/eventDB.sqlite /root/current-deployment-data/experiment-output/0013/slave-*/*.trc
    Events loaded: 116801
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0014: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0014
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0014/eventDB.sqlite /root/current-deployment-data/experiment-output/0014/slave-*/*.trc
    Events loaded: 116729
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0015: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0015
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0015/eventDB.sqlite /root/current-deployment-data/experiment-output/0015/slave-*/*.trc
    Events loaded: 154971
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0016: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0016
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0016/eventDB.sqlite /root/current-deployment-data/experiment-output/0016/slave-*/*.trc
    Events loaded: 155073
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0017: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0017
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0017/eventDB.sqlite /root/current-deployment-data/experiment-output/0017/slave-*/*.trc
    Events loaded: 155051
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0018: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0018
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0018/eventDB.sqlite /root/current-deployment-data/experiment-output/0018/slave-*/*.trc
    Events loaded: 154976
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0019: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0019
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0019/eventDB.sqlite /root/current-deployment-data/experiment-output/0019/slave-*/*.trc
    Events loaded: 155085
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0020: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0020
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0020/eventDB.sqlite /root/current-deployment-data/experiment-output/0020/slave-*/*.trc
    Events loaded: 190787
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0021: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0021
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0021/eventDB.sqlite /root/current-deployment-data/experiment-output/0021/slave-*/*.trc
    Events loaded: 191103
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0022: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0022
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0022/eventDB.sqlite /root/current-deployment-data/experiment-output/0022/slave-*/*.trc
    Events loaded: 190754
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0023: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0023
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0023/eventDB.sqlite /root/current-deployment-data/experiment-output/0023/slave-*/*.trc
    Events loaded: 191247
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0024: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0024
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0024/eventDB.sqlite /root/current-deployment-data/experiment-output/0024/slave-*/*.trc
    Events loaded: 190944
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0025: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0025
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0025/eventDB.sqlite /root/current-deployment-data/experiment-output/0025/slave-*/*.trc
    Events loaded: 229545
  > Loaded trace into database in 1 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0026: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0026
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0026/eventDB.sqlite /root/current-deployment-data/experiment-output/0026/slave-*/*.trc
    Events loaded: 229657
  > Loaded trace into database in 1 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0027: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0027
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0027/eventDB.sqlite /root/current-deployment-data/experiment-output/0027/slave-*/*.trc
    Events loaded: 229363
  > Loaded trace into database in 1 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0028: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0028
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0028/eventDB.sqlite /root/current-deployment-data/experiment-output/0028/slave-*/*.trc
    Events loaded: 229592
  > Loaded trace into database in 1 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0029: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0029
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0029/eventDB.sqlite /root/current-deployment-data/experiment-output/0029/slave-*/*.trc
    Events loaded: 229546
  > Loaded trace into database in 1 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0030: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0030
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0030/eventDB.sqlite /root/current-deployment-data/experiment-output/0030/slave-*/*.trc
    Events loaded: 266725
  > Loaded trace into database in 1 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 2 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0031: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0031
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0031/eventDB.sqlite /root/current-deployment-data/experiment-output/0031/slave-*/*.trc
    Events loaded: 266895
  > Loaded trace into database in 1 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 2 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0032: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0032
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0032/eventDB.sqlite /root/current-deployment-data/experiment-output/0032/slave-*/*.trc
    Events loaded: 266924
  > Loaded trace into database in 1 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 2 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0033: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0033
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0033/eventDB.sqlite /root/current-deployment-data/experiment-output/0033/slave-*/*.trc
    Events loaded: 266507
  > Loaded trace into database in 1 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 2 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
Finished processing results. First unprocessed: 35
Finished processing results. First unprocessed: 36
0034: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0034
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0034/eventDB.sqlite /root/current-deployment-data/experiment-output/0034/slave-*/*.trc
Finished processing results. First unprocessed: 37
Finished processing results. First unprocessed: 38
    Events loaded: 266553
  > Loaded trace into database in 1 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
Finished processing results. First unprocessed: 39
Finished processing results. First unprocessed: 40
Finished processing results. First unprocessed: 41
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 2 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
Finished processing results. First unprocessed: 42
Finished continuous result analysis.
