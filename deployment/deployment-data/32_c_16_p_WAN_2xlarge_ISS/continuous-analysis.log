result_processor 0 8
result_processor 1 8
result_processor 2 8
result_processor 3 8
result_processor 4 8
result_processor 5 8
result_processor 6 8
result_processor 7 8
Processing experiment results. Start: 0 Step: 8
Processing experiment results. Start: 2 Step: 8
Processing experiment results. Start: 1 Step: 8
Processing experiment results. Start: 3 Step: 8
Processing experiment results. Start: 4 Step: 8
Processing experiment results. Start: 5 Step: 8
Processing experiment results. Start: 6 Step: 8
Processing experiment results. Start: 7 Step: 8
0000: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0000
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0000/eventDB.sqlite /root/current-deployment-data/experiment-output/0000/slave-*/*.trc
    Events loaded: 104166
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 0 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0001: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0001
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0001/eventDB.sqlite /root/current-deployment-data/experiment-output/0001/slave-*/*.trc
    Events loaded: 196444
  > Loaded trace into database in 0 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 1 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0002: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0002
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0002/eventDB.sqlite /root/current-deployment-data/experiment-output/0002/slave-*/*.trc
    Events loaded: 257966
  > Loaded trace into database in 1 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 2 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0003: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0003
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0003/eventDB.sqlite /root/current-deployment-data/experiment-output/0003/slave-*/*.trc
    Events loaded: 387906
  > Loaded trace into database in 1 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 3 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0004: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0004
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0004/eventDB.sqlite /root/current-deployment-data/experiment-output/0004/slave-*/*.trc
    Events loaded: 511719
  > Loaded trace into database in 2 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 4 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0005: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0005
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0005/eventDB.sqlite /root/current-deployment-data/experiment-output/0005/slave-*/*.trc
    Events loaded: 621559
  > Loaded trace into database in 2 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 5 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0006: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0006
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0006/eventDB.sqlite /root/current-deployment-data/experiment-output/0006/slave-*/*.trc
    Events loaded: 777566
  > Loaded trace into database in 3 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 7 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0007: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0007
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0007/eventDB.sqlite /root/current-deployment-data/experiment-output/0007/slave-*/*.trc
    Events loaded: 854396
  > Loaded trace into database in 3 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 7 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
0008: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0008
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0008/eventDB.sqlite /root/current-deployment-data/experiment-output/0008/slave-*/*.trc
    Events loaded: 929236
  > Loaded trace into database in 4 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 8 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
Finished processing results. First unprocessed: 15
Finished processing results. First unprocessed: 10
Finished processing results. First unprocessed: 13
0009: analyzing
Analyzing: /root/current-deployment-data/experiment-output/0009
  > Loading trace into database...
python3 scripts/analyze/load-logs.py /root/current-deployment-data/experiment-output/0009/eventDB.sqlite /root/current-deployment-data/experiment-output/0009/slave-*/*.trc
Finished processing results. First unprocessed: 11
Finished processing results. First unprocessed: 16
Finished processing results. First unprocessed: 14
Finished processing results. First unprocessed: 12
    Events loaded: 1004950
  > Loaded trace into database in 4 s.
  > Running queries on trace database: queries/ethereum.sql
SELECT *
FROM ethereum
Query time: 0.000 seconds
Rows returned: 0

Total running time: 0.000 seconds
  > Processed 'queries/ethereum.sql' in 0 s.
  > Running queries on trace database: queries/aggregates.sql
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last response obtained by the client first to finish obtaining responses
-- Then, cut off 5 seconds from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts >= (SELECT t
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId)) / 2)
  AND ts <= (SELECT t
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId) as tb1
    ORDER BY t
    LIMIT 1
    OFFSET (SELECT COUNT(*)
            FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId)) / 2);
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/aggregates.sql' in 9 s.
  > Running queries on trace database: queries/histograms.sql
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
-- Truncate request table to include only rows with timestamps between:
--   the first response obtained by the last client to obtain a response
--   and
--   the last request obtained by the client first to finish sending requests
-- Then, cut off 5 second from each end.
-- We could use a view here too, but a physical table is much faster to access.
-- The script processing this file normally makes sure that
-- changes made by this script to the database are rolled back and are not persisted.
CREATE TABLE request_truncated as
SELECT *
FROM request
WHERE
  ts - 2000000 >= (SELECT max(t)
    FROM (SELECT min(ts) as t
      FROM request
      WHERE event = 'REQ_FINISHED'
      GROUP BY nodeId))
  AND ts + 2000000 <= (SELECT min(t)
    FROM (SELECT max(ts) as t
      FROM request
      WHERE event = 'REQ_SEND'
      GROUP BY nodeId))
Traceback (most recent call last):
  File "/root/scripts/analyze/run-queries.py", line 67, in <module>
    rows = cur.execute(q).fetchall()
sqlite3.OperationalError: table request_truncated already exists
  > Processed 'queries/histograms.sql' in 0 s.
Finished processing results. First unprocessed: 17
Finished continuous result analysis.
